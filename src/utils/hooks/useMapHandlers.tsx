import { useCallback, useEffect, useRef, useState } from 'react';
import MapView, { Region } from 'react-native-maps';
import Polyline from '@mapbox/polyline';
import { ulid } from 'ulid';
import type {
  ItineraryPlannerMode,
  RouteInfo,
  RouteNodeCoord,
  RouteNodeInfo,
} from '@components/itinerary/types/types';
import useModalHandlers from '@hooks/useModalHandlers';
import { useAppDispatch, useAppSelector } from '@redux/hooks';
import {
  writeTale_createTaleItinerary,
  writeTale_setTaleItinerary,
} from '@redux/reducers/writeTaleSlice';
import { LATITUDE_DELTA, LONGITUDE_DELTA } from '@constants/constants';
import { BACKEND_BASE_URL } from '@env';

type useItineraryManagerProps = {
  mode: ItineraryPlannerMode;
  itineraryId?: string;
};

const useMapHandlers = ({}: useItineraryManagerProps) => {
  const mapRef = useRef<MapView | null>(null);
  const dispatch = useAppDispatch();
  // Itinerary is either new or fetched from api.
  // Mode = 'new'

  // Both edit and view modes query tale data from api, then this hook assigns itinerary from tale cache to itinerarySlice
  // Mode = 'edit' => fetch tale from api, itinerary in tale gets assigned to itinerarySlice when ItineraryScreen is mounted, and reset when unmounted. Enables post button.
  // Mode = 'view' => fetch tale from api, itinerary in tale gets assigned to itinerarySlice when ItineraryScreen is mounted, and reset when unmounted.

  const { itinerary } = useAppSelector(state => state.writeTale);
  const [routes, setRoutes] = useState<RouteInfo[]>(itinerary.routes);
  const [selectedRouteId, setSelectedRouteId] = useState<string>(routes[0].id);
  const selectedRoute = routes.filter(
    (route: RouteInfo) => route.id === selectedRouteId,
  )[0];

  const [modalInitialValue, setModalInitialValue] = useState<string>(
    selectedRoute.name,
  );

  const { modalIsOpen, closeModal, openModal } = useModalHandlers();

  const onAddRoute = useCallback(
    (name: string) => {
      // Change to uuid
      const newId = ulid();
      setRoutes(prevRoutes => [
        { id: newId, name, routeNodes: [], polyline: [], encodedPolyline: '' },
        ...prevRoutes,
      ]);
      closeModal();
      setSelectedRouteId(newId);
    },
    [closeModal, setRoutes, setSelectedRouteId],
  );

  const onClearRoute = useCallback(() => {
    console.log('onClearRoute');
    setRoutes(prevRoutes =>
      prevRoutes.map(route => {
        if (route.id === selectedRouteId) {
          return { ...route, routeNodes: [], polyline: [] };
        }
        return route;
      }),
    );
  }, [selectedRouteId, setRoutes]);

  const onDeleteRoute = useCallback(() => {
    if (routes.length > 1) {
      const filteredRoutes = routes.filter(
        route => route.id !== selectedRouteId,
      );

      setRoutes(filteredRoutes);
      setSelectedRouteId(filteredRoutes[0].id);
    }
  }, [routes, selectedRouteId, setRoutes, setSelectedRouteId]);

  const onHoldRoute = useCallback(
    (routeName: string) => {
      setModalInitialValue(routeName);
      openModal();
    },
    [openModal, setModalInitialValue],
  );

  const onSelectRoute = useCallback(
    (routeId: string): void => {
      setSelectedRouteId(routeId);

      // Animate camera to birds eye view of all pins
    },
    [setSelectedRouteId],
  );

  // Optimise ui performance since adding marker will have short delay before marker appears
  const onAddMarker = useCallback(
    (newRouteNode: RouteNodeInfo): void => {
      setRoutes(prevRoutes =>
        prevRoutes.map(route => {
          if (route.id === selectedRouteId) {
            return {
              ...route,
              routeNodes: [...route.routeNodes, newRouteNode],
              encodedPolyline: '',
            };
          }
          return route;
        }),
      );
    },
    [selectedRouteId, setRoutes],
  );

  const onDeleteMarker = useCallback(
    (placeId: string): void => {
      setRoutes(prevRoutes =>
        prevRoutes.map(route => {
          if (route.id === selectedRouteId) {
            return {
              ...route,
              routeNodes: route.routeNodes.filter(
                (routeNode: RouteNodeInfo) => routeNode.placeId !== placeId,
              ),
              encodedPolyline: '',
            };
          }
          return route;
        }),
      );
    },
    [selectedRouteId, setRoutes],
  );

  const onAddPlace = useCallback(
    (routeNode: RouteNodeInfo) => onAddMarker(routeNode),
    [onAddMarker],
  );

  const onDeletePlace = useCallback(
    (placeId: string) => {
      onDeleteMarker(placeId);
    },
    [onDeleteMarker],
  );

  const onMapPress = useCallback(
    // check for MapEvent type in react-native-maps
    (event: any) => {
      event.stopPropagation();

      // Can make HTTP request to backend for fetching details based on coordinates pressed.

      onAddMarker('', '', '', event.nativeEvent.coordinate, false); // Look into autogenerated placeId
    },
    [onAddMarker],
  );

  const onUpdateRouteName = useCallback(
    (name: string) => {
      // dispatch(updateRouteName({name}));
      setRoutes(prevRoutes =>
        prevRoutes.map(route => {
          if (route.id === selectedRouteId) {
            return { ...route, name };
          }
          return route;
        }),
      );
      closeModal();
    },
    [selectedRouteId, closeModal, setRoutes],
  );

  const onStartRouting = useCallback(async () => {
    // HTTP request to Spring Boot backend server to call Google Distance Matrix API.
    // Backend receives distance matrix of the given coordinates and travel mode.
    // Determine order of travelling in backend.
    // Return ordered route nodes.
    const url = BACKEND_BASE_URL + '/directions';

    const data = selectedRoute.routeNodes.map(
      (routeNode: RouteNodeInfo) => routeNode.coord,
    );

    const options = {
      method: 'POST',
      headers: {
        Accept: 'application/json',
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(data),
    };

    try {
      // Use axios
      // const directionsReponse = await axios.post(url, JSON.stringify(data), {headers: {
      //   Accept: "application/json",
      //   "Content-Type": "application/json",
      // }})
      const response = await fetch(url, options);
      const directionsResponse = await response.json();

      setRoutes(prevRoutes =>
        prevRoutes.map(route => {
          if (route.id === selectedRouteId) {
            const orderedRouteNodes: RouteNodeInfo[] = [];

            directionsResponse.order.forEach((id: number) => {
              const currentNode = route.routeNodes[id];
              if (currentNode) {
                orderedRouteNodes.push(currentNode);
              }
            });

            // An array which contains information about a leg of the route, between two locations within the given route.
            // A separate leg will be present for each waypoint or destination specified.
            // (A route with no waypoints will contain exactly one leg within the legs array.) Each leg consists of a series of steps.
            let polyline: RouteNodeCoord[] = [];
            directionsResponse.directionsResultList.forEach(
              (direction: {
                routes: { overviewPolyline: { encodedPath: string } }[];
              }) => {
                const directionCoords = Polyline.decode(
                  direction.routes[0].overviewPolyline.encodedPath,
                ).map((coord: any[]) => ({
                  latitude: coord[0],
                  longitude: coord[1],
                }));
                polyline = polyline.concat(directionCoords);
              },
            );

            const encodedPolyline = Polyline.encode(
              polyline.map(coord => [coord.latitude, coord.longitude]),
            );

            return {
              ...route,
              routeNodes: orderedRouteNodes,
              polyline,
              encodedPolyline,
            };
          }
          return route;
        }),
      );
    } catch (e) {
      console.error(e);
    }
  }, [Polyline, selectedRoute, setRoutes]);

  const onCloseModal = useCallback(() => {
    closeModal();
  }, [closeModal]);

  useEffect(() => {
    // Add animation to a certain location without places added
    console.log('Selected route: ', selectedRoute);

    if (selectedRoute.routeNodes.length === 1) {
      // Modify to use average of all routeNodes as region
      const { latitude, longitude } = selectedRoute.routeNodes[0].coord;
      const region: Region = {
        latitude,
        longitude,
        latitudeDelta: LATITUDE_DELTA,
        longitudeDelta: LONGITUDE_DELTA,
      };
      mapRef.current?.animateToRegion(region, 200);
    } else if (selectedRoute.routeNodes.length > 1) {
      mapRef.current?.fitToCoordinates(
        selectedRoute.routeNodes.map(
          (routeNode: RouteNodeInfo) => routeNode.coord,
        ),
        {
          edgePadding: { top: 80, right: 50, bottom: 200, left: 50 },
          animated: false,
        },
      );
    }
  }, [mapRef, selectedRoute]);

  useEffect(() => {
    console.log('ItineraryPlanner mounted');
    // If itinerary id does not exist, create itinerary
    if (!itinerary.id) {
      // Use user id from global object as creatorId
      dispatch(writeTale_createTaleItinerary({ creatorId: '' }));
    }

    // Load routes from backend based on itineraryId and call setRoutes

    return () => {
      console.log('ItineraryPlanner unmounted');
      // Dispatch an action to update itinerary in NewItineraryPost.
      dispatch(writeTale_setTaleItinerary({ routes }));
    };
  }, [
    routes,
    writeTale_createTaleItinerary,
    writeTale_setTaleItinerary,
    dispatch,
  ]);

  return {
    mapRef,
    routes,
    selectedRouteId,
    selectedRoute,
    modalIsOpen,
    modalInitialValue,
    onAddRoute,
    onClearRoute,
    onDeleteRoute,
    onHoldRoute,
    onSelectRoute,
    // onAddMarker,
    // onDeleteMarker,
    onAddPlace,
    onDeletePlace,
    onMapPress,
    onUpdateRouteName,
    onStartRouting,
    onCloseModal,
  };
};

export default useMapHandlers;
