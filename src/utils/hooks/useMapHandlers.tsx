import { useCallback, useState } from "react";
// import { LatLng, MapEvent, Region } from "react-native-maps";
import Polyline from "@mapbox/polyline";

import { RouteInfo, RouteNodeCoord, RouteNodeInfo } from "../types/route";

const useMapHandlers = (navigation: { goBack: () => void }) => {
  const [routes, setRoutes] = useState<RouteInfo[]>([
    {
      id: "1", // to change to uuid
      name: "Day 1",
      routeNodes: [],
      isRouted: false,
    },
  ]);
  const [selectedRouteId, setSelectedRouteId] = useState<string>(routes[0].id);
  const selectedRoute = routes.filter(
    (route: RouteInfo) => route.id === selectedRouteId
  )[0];

  const [polylines, setPolylines] = useState<Array<RouteNodeCoord>>([]);

  const [modalIsOpen, setModalIsOpen] = useState<boolean>(false);
  const [modalInitialValue, setModalInitialValue] = useState<string>(
    selectedRoute.name
  );

  const onAddRoute = useCallback((name: string) => {
    // Change to uuid
    const newId = Math.random().toString();
    setRoutes((prevRoutes) => [
      { id: newId, name, routeNodes: [], isRouted: false },
      ...prevRoutes,
    ]);
    setModalIsOpen(false);
    setSelectedRouteId(newId);
  }, []);

  const onClearRoute = useCallback(() => {
    setRoutes((prevRoutes) =>
      prevRoutes.map((route) => {
        if (route.id === selectedRouteId) {
          return { ...route, routeNodes: [] };
        }
        return route;
      })
    );
  }, [selectedRouteId]);

  const onDeleteRoute = useCallback(() => {
    if (routes.length > 1) {
      const filteredRoutes = routes.filter(
        (route) => route.id !== selectedRouteId
      );

      setRoutes(filteredRoutes);
      setSelectedRouteId(filteredRoutes[0].id);
    }
  }, [routes, selectedRouteId]);

  const onHoldRoute = useCallback((routeName: string) => {
    setModalInitialValue(routeName);
    setModalIsOpen(true);
  }, []);

  const onSelectRoute = useCallback((routeId: string): void => {
    setSelectedRouteId(routeId);

    // Animate camera to birds eye view of all pins
  }, []);

  // Optimise ui performance since adding marker will have short delay before marker appears
  const onAddMarker = useCallback(
    (
      placeId: string,
      name: string,
      address: string = "nil",
      openNow: boolean,
      coord: RouteNodeCoord
    ): void => {
      const newRouteNode = { placeId, name, address, openNow, coord };
      setRoutes((prevRoutes) =>
        prevRoutes.map((route) => {
          if (route.id === selectedRouteId) {
            return {
              ...route,
              routeNodes: [...route.routeNodes, newRouteNode],
              isRouted: false,
            };
          }
          return route;
        })
      );
    },
    [selectedRouteId]
  );

  const onDeleteMarker = useCallback(
    (placeId: string): void => {
      setRoutes((prevRoutes) =>
        prevRoutes.map((route) => {
          if (route.id === selectedRouteId) {
            return {
              ...route,
              routeNodes: route.routeNodes.filter(
                (routeNode) => routeNode.placeId !== placeId // Comparison
              ),
              isRouted: false,
            };
          }
          return route;
        })
      );
    },
    [selectedRouteId]
  );

  const onAddPlace = useCallback(
    (routeNode: RouteNodeInfo) => {
      onAddMarker(
        routeNode.placeId,
        routeNode.name,
        routeNode.address,
        routeNode.openNow,
        routeNode.coord
      );
    },
    [onAddMarker]
  );

  const onDeletePlace = useCallback(
    (placeId: string) => {
      onDeleteMarker(placeId);
    },
    [onDeleteMarker]
  );

  const onMapPress = useCallback(
    // check for MapEvent type in react-native-maps
    (event: any) => {
      event.stopPropagation();

      // Can make HTTP request to backend for fetching details based on coordinates pressed.

      onAddMarker("", "", "", false, event.nativeEvent.coordinate); // Look into autogenerated placeId
    },
    [onAddMarker]
  );

  const onUpdateRouteName = useCallback(
    (name: string) => {
      setRoutes((prevRoutes) =>
        prevRoutes.map((route) => {
          if (route.id === selectedRouteId) {
            return { ...route, name };
          }
          return route;
        })
      );
      setModalIsOpen(false);
    },
    [selectedRouteId]
  );

  const onStartRouting = useCallback(async () => {
    // HTTP request to Spring Boot backend server to call Google Distance Matrix API.
    // Backend receives distance matrix of the given coordinates and travel mode.
    // Determine order of travelling in backend.
    // Return ordered route nodes.
    // setRoutes((prevRoutes) =>
    //   prevRoutes.map((route) => {
    //     if (route.id === selectedRouteId) {
    //       return { ...route, isRouted: true }; // Add ordered coords to this object
    //     }
    //     return route;
    //   })
    // );
    // const url = "http://192.168.1.20:8080/directions";
    const url = "http://localhost:8080/directions";
    console.log(JSON.stringify(routes, null, 4));

    const data = selectedRoute.routeNodes.map((routeNode) => routeNode.coord);

    const options = {
      method: "POST",
      headers: {
        Accept: "application/json",
        "Content-Type": "application/json",
      },
      body: JSON.stringify(data),
    };

    try {
      const response = await fetch(url, options);
      const directionsResponse = await response.json();
      console.log("DIRECTIONS RESPONSE: ", directionsResponse); 
      
      setRoutes((prevRoutes) =>
        prevRoutes.map((route) => {
          if (route.id === selectedRouteId) {
            const orderedRouteNodes: RouteNodeInfo[] = [];

            directionsResponse.order.forEach((id: number) => {
              const currentNode = route.routeNodes[id];
              if (currentNode) {
                orderedRouteNodes.push(currentNode);
              }
            });
            console.log("ORDERED ROUTE NODES: ", orderedRouteNodes);
            return { ...route, routeNodes: orderedRouteNodes, isRouted: true }; // Add ordered coords to this object
          }
          return route;
        })
      );

      //   console.log();
      //   console.log(JSON.stringify(directionsResponse, null, 4));
      //   console.log();

      // An array which contains information about a leg of the route, between two locations within the given route.
      // A separate leg will be present for each waypoint or destination specified.
      // (A route with no waypoints will contain exactly one leg within the legs array.) Each leg consists of a series of steps.

      // array of RouteNodeCoord objects

      let lines: RouteNodeCoord[] = [];
      directionsResponse.directionsResultList.forEach(
        (direction: {
          routes: { overviewPolyline: { encodedPath: string } }[];
        }) => {
          const directionCoords = Polyline.decode(
            direction.routes[0].overviewPolyline.encodedPath
          ).map((coord: any[]) => ({
            latitude: coord[0],
            longitude: coord[1],
          }));
          lines = lines.concat(directionCoords);
        }
      );

      setPolylines(lines);
    } catch (e) {
      console.log(e);
    }
  }, [selectedRoute]);

  const onCloseModal = useCallback(() => {
    setModalIsOpen(false);
  }, []);

  const onExit = () => {
    navigation.goBack();
  };

  return {
    routes,
    selectedRouteId,
    selectedRoute,
    polylines,
    modalIsOpen,
    modalInitialValue,
    onAddRoute,
    onClearRoute,
    onDeleteRoute,
    onHoldRoute,
    onSelectRoute,
    onAddMarker,
    onDeleteMarker,
    onAddPlace,
    onDeletePlace,
    onMapPress,
    onUpdateRouteName,
    onStartRouting,
    onExit,
    onCloseModal,
  };
};

export default useMapHandlers;
