import { useCallback, useState } from "react";
// import { LatLng, MapEvent, Region } from "react-native-maps";
import axios from "axios";
import Polyline from "@mapbox/polyline";
import type {
  RouteInfo,
  RouteNodeCoord,
  RouteNodeInfo,
} from "../../components/itinerary/types/types";

const useMapHandlers = (navigation: { goBack: () => void }) => {
  const [routes, setRoutes] = useState<RouteInfo[]>([
    {
      id: "1", // to change to uuid
      name: "Day 1",
      routeNodes: [],
      isRouted: false,
    },
  ]);
  const [selectedRouteId, setSelectedRouteId] = useState<string>(routes[0].id);
  const selectedRoute = routes.filter(
    (route: RouteInfo) => route.id === selectedRouteId,
  )[0];
  const [polylines, setPolylines] = useState<RouteNodeCoord[]>([]);
  const [modalIsOpen, setModalIsOpen] = useState<boolean>(false);
  const [modalInitialValue, setModalInitialValue] = useState<string>(
    selectedRoute.name,
  );

  const onAddRoute = useCallback(
    (name: string) => {
      // Change to uuid
      const newId = Math.random().toString();
      setRoutes(prevRoutes => [
        { id: newId, name, routeNodes: [], isRouted: false },
        ...prevRoutes,
      ]);
      setModalIsOpen(false);
      setSelectedRouteId(newId);
    },
    [setModalIsOpen, setRoutes, setSelectedRouteId],
  );

  const onClearRoute = useCallback(() => {
    setRoutes(prevRoutes =>
      prevRoutes.map(route => {
        if (route.id === selectedRouteId) {
          return { ...route, routeNodes: [] };
        }
        return route;
      }),
    );
  }, [selectedRouteId, setRoutes]);

  const onDeleteRoute = useCallback(() => {
    if (routes.length > 1) {
      const filteredRoutes = routes.filter(
        route => route.id !== selectedRouteId,
      );

      setRoutes(filteredRoutes);
      setSelectedRouteId(filteredRoutes[0].id);
    }
  }, [routes, selectedRouteId, setRoutes, setSelectedRouteId]);

  const onHoldRoute = useCallback(
    (routeName: string) => {
      setModalInitialValue(routeName);
      setModalIsOpen(true);
    },
    [setModalInitialValue, setModalIsOpen],
  );

  const onSelectRoute = useCallback(
    (routeId: string): void => {
      setSelectedRouteId(routeId);

      // Animate camera to birds eye view of all pins
    },
    [setSelectedRouteId],
  );

  // Optimise ui performance since adding marker will have short delay before marker appears
  const onAddMarker = useCallback(
    (
      placeId: string,
      name: string,
      address: string = "nil",
      coord: RouteNodeCoord,
      openNow?: boolean,
    ): void => {
      const newRouteNode = { placeId, name, address, openNow, coord };
      setRoutes(prevRoutes =>
        prevRoutes.map(route => {
          if (route.id === selectedRouteId) {
            return {
              ...route,
              routeNodes: [...route.routeNodes, newRouteNode],
              isRouted: false,
            };
          }
          return route;
        }),
      );
    },
    [selectedRouteId, setRoutes],
  );

  const onDeleteMarker = useCallback(
    (placeId: string): void => {
      setRoutes(prevRoutes =>
        prevRoutes.map(route => {
          if (route.id === selectedRouteId) {
            return {
              ...route,
              routeNodes: route.routeNodes.filter(
                (routeNode: RouteNodeInfo) => routeNode.placeId !== placeId, // Comparison
              ),
              isRouted: false,
            };
          }
          return route;
        }),
      );
    },
    [selectedRouteId, setRoutes],
  );

  const onAddPlace = useCallback(
    (routeNode: RouteNodeInfo) => {
      onAddMarker(
        routeNode.placeId,
        routeNode.name,
        routeNode.address,
        routeNode.coord,
        routeNode.openNow,
      );
    },
    [onAddMarker],
  );

  const onDeletePlace = useCallback(
    (placeId: string) => {
      onDeleteMarker(placeId);
    },
    [onDeleteMarker],
  );

  const onMapPress = useCallback(
    // check for MapEvent type in react-native-maps
    (event: any) => {
      event.stopPropagation();

      // Can make HTTP request to backend for fetching details based on coordinates pressed.

      onAddMarker("", "", "", event.nativeEvent.coordinate, false); // Look into autogenerated placeId
    },
    [onAddMarker],
  );

  const onUpdateRouteName = useCallback(
    (name: string) => {
      setRoutes(prevRoutes =>
        prevRoutes.map(route => {
          if (route.id === selectedRouteId) {
            return { ...route, name };
          }
          return route;
        }),
      );
      setModalIsOpen(false);
    },
    [selectedRouteId, setModalIsOpen, setRoutes],
  );

  const onStartRouting = useCallback(async () => {
    // HTTP request to Spring Boot backend server to call Google Distance Matrix API.
    // Backend receives distance matrix of the given coordinates and travel mode.
    // Determine order of travelling in backend.
    // Return ordered route nodes.
    // setRoutes((prevRoutes) =>
    //   prevRoutes.map((route) => {
    //     if (route.id === selectedRouteId) {
    //       return { ...route, isRouted: true }; // Add ordered coords to this object
    //     }
    //     return route;
    //   })
    // );
    // const url = "http://192.168.1.20:8080/directions";
    const url = "http://localhost:8080/directions";

    const data = selectedRoute.routeNodes.map(
      (routeNode: RouteNodeInfo) => routeNode.coord,
    );

    const options = {
      method: "POST",
      headers: {
        Accept: "application/json",
        "Content-Type": "application/json",
      },
      body: JSON.stringify(data),
    };

    try {
      // Use axios
      // const directionsReponse = await axios.post(url, JSON.stringify(data), {headers: {
      //   Accept: "application/json",
      //   "Content-Type": "application/json",
      // }})
      const response = await fetch(url, options);
      const directionsResponse = await response.json();

      setRoutes(prevRoutes =>
        prevRoutes.map(route => {
          if (route.id === selectedRouteId) {
            const orderedRouteNodes: RouteNodeInfo[] = [];

            directionsResponse.order.forEach((id: number) => {
              const currentNode = route.routeNodes[id];
              if (currentNode) {
                orderedRouteNodes.push(currentNode);
              }
            });
            return { ...route, routeNodes: orderedRouteNodes, isRouted: true }; // Add ordered coords to this object
          }
          return route;
        }),
      );

      // An array which contains information about a leg of the route, between two locations within the given route.
      // A separate leg will be present for each waypoint or destination specified.
      // (A route with no waypoints will contain exactly one leg within the legs array.) Each leg consists of a series of steps.

      // array of RouteNodeCoord objects

      let lines: RouteNodeCoord[] = [];
      directionsResponse.directionsResultList.forEach(
        (direction: {
          routes: { overviewPolyline: { encodedPath: string } }[];
        }) => {
          const directionCoords = Polyline.decode(
            direction.routes[0].overviewPolyline.encodedPath,
          ).map((coord: any[]) => ({
            latitude: coord[0],
            longitude: coord[1],
          }));
          lines = lines.concat(directionCoords);
        },
      );

      setPolylines(lines);
    } catch (e) {
      console.log(e);
    }
  }, [Polyline, selectedRoute, setRoutes, setPolylines]);

  const onCloseModal = useCallback(() => {
    setModalIsOpen(false);
  }, [setModalIsOpen]);

  const onExit = useCallback(() => {
    navigation.goBack();
  }, [navigation]);

  return {
    routes,
    selectedRouteId,
    selectedRoute,
    polylines,
    modalIsOpen,
    modalInitialValue,
    onAddRoute,
    onClearRoute,
    onDeleteRoute,
    onHoldRoute,
    onSelectRoute,
    onAddMarker,
    onDeleteMarker,
    onAddPlace,
    onDeletePlace,
    onMapPress,
    onUpdateRouteName,
    onStartRouting,
    onExit,
    onCloseModal,
  };
};

export default useMapHandlers;
